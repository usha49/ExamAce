This is called the
pivot.Partition the list A by placing v in some position j, such that oall elements before position
j are less than or equal to v o all elements after position j are greater than or equal to

Soring
13
v.Recursively sort the sublists A[0] through A[j-1] and A[j+1] through A[N-1].Return A[0]
through A[j-1] followed by A[j] (the pivot) followed by A[j+1] through A[N-1].
Quick Sort Code:
void QuickSort(int A[], int N)
{
QSort(A, 0, N - 1);
}
void QSort(ItemType A[], int low, int high)
{ int pivotloc; if (low
< high)
{ pivotloc = partition(A, low, high);
QSort(A, low, pivotloc - 1);
QSort(A, pivotloc + 1, high);
}} int partition(int A[], int low, int high) { int down, up;
int pivot;
pivot = A[low];
/* choose first element as the
pivot down = low;
/* Initialize pointers */ up =
high;
while (down < up)
{ while (A[down] <= pivot && down < high)
/* move right */
down++;
while (A[up] > pivot)
/* move left */
up--;
if (down < up)
/* exchange element at up and down */
swap (&A[down], &A[up]); }
swap (&A[low], &A[up]);
/* Place pivot at its proper position
*/
return up;
/* return the pivot location */
}
Description of partition procedure: Choose any element as the pivot, here we choose the first
element as the first item in the list.