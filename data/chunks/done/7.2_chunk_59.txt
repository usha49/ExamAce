For a list of size N, N-1 passes
are made, and for each pass the elements from a[0] through a[i-1] are sorted.Take the element
a[i], find the proper place to insert a[i] within 0, 1, …, i-1 and insert a[i] at that place.To insert
new item into the list:Search the position in the sorted sublist from last toward first,While
searching, move elements one position right to make a room to insert a[i] ,Place a[i] in its
proper place.C-Procedure:void InsertionSort(int a[], int N){int i, j;
int hold; /* the current element to insert */
for (i = 1; i < N; i++) // Insert a[i] into the sorted list
{ hold = a[i]; /* hold the element to be inserted */
for (j = i-1; j >= 0 && a[j] > hold; j--)
//Move right 1 position all
a[j+1] = a[j];
//elements greater than hold
a[j+1] = hold; /* Place hold in its proper place
*/ }}
Efficiency:No of comparisons: Best case: n – 1 Worst case: n2/2 + O(n) Average case: n2/4 +
O (n).No of assignments (movements):Best case: 2*(n-1) // moving from a[i] to hold and

Soring
12
back,Worst case: n2/2 + O(n),Average case: n2/4 + O (n).Hence running time of insertion sort
is O(n2) in worst and average case and O(n) in best case and space requirement is O(1).
Advantages:It is an excellent method whenever a list is nearly in the correct order and few
items are removed from their correct location.Since there is no swapping, it is twice as faster
than bubble sort.Disadvantage:It makes a large amount of shifting of sorted elements when
inserting later elements.Selection Sort:The selection sort algorithm sorts a list by selecting
successive elements in order and placing into their proper sorted positions.A list of size N
require N-1 passes:For each pass I,Find the position of ith largest (or smallest) element.To place
the ith largest (of smallest) in its proper position, swap this element with the element currently
in the position of its largest (or smallest) element.
C – Procedure
void SelectionSort(int a[], int N)
{
int i, j; int
maxpos;
for (i = N-1; i > 0; i--)
//Find the position of largest element from 0 to i
{ maxpos = 0; for (j = 1; j <= i; j++)
if (a[j] > a[maxpos])
maxpos = j;
if(maxpos != i) swap(&a[maxpos], &a[i]);
//Place the ith largest element
}
// in its place
}
Efficiency:No of comparisons:Best, average and worst case: n(n – 1)/2 .No of assignments
(movements):Best, average and worst case: 3(n – 1), (total n – 1 swaps).If we include a test, to
prevent interchanging an element with itself, the number of interchanges in the best case would
be 0.Hence running time of selection sort is O(n2) and additional space requirements is O(1).
Advantages:It is the best algorithm in regard to data movement.An element that is in its
correct final position will never be moved and only one swap is needed to place an element in
its proper position.Disadvantages:In case of number of comparisons, it pays no attention to the
original ordering of the list.